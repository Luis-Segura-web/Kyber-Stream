<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/copilot-instructions.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/copilot-instructions.md" />
              <option name="originalContent" value="# GitHub Copilot Instructions — IPTV Android (Media3 + VLC + Xtream Codes, single-connection)&#10;&#10;&gt; **Contexto**&#10;&gt; App IPTV para Android (TV y móvil) con Xtream Codes (live/VOD/series/EPG). **Solo se permite 1 conexión de streaming activa por dispositivo**. Player principal: **Media3**. Alternativo: **VLC (LibVLC)**. DI con Hilt, UI en Compose.&#10;&#10;---&#10;&#10;## Idioma de comunicación&#10;- **Toda la comunicación, respuestas y generación de código por parte del asistente deben ser en español latino.**&#10;&#10;---&#10;&#10;## Estilo y lenguaje de código&#10;- Comentarios en **español latino**.&#10;- Identificadores en **inglés** (`camelCase` / `PascalCase`).&#10;- Formato con **ktlint/spotless**.&#10;&#10;## Stack tecnológico (fijo)&#10;- **Kotlin**: 2.2.0&#10;- **AGP**: 8.12.0  &#10;- **KSP**: 2.2.0-2.0.2&#10;- **UI**: Compose + Hilt&#10;- **Async**: Coroutines/Flow&#10;- **Player**: Media3 (ExoPlayer) + LibVLC (alternativo)&#10;- **Network**: Retrofit o Ktor + kotlinx.serialization&#10;- **Storage**: Room + DataStore (proto) + EncryptedSharedPreferences&#10;- **Background**: WorkManager&#10;- **Image**: Coil&#10;- **Logging**: Timber&#10;&#10;---&#10;&#10;## Regla fundamental: **Single Streaming Connection**&#10;&#10;### Restricciones obligatorias&#10;- **Nunca** tener dos reproducciones simultáneas (local, PiP, background, o cast).&#10;- Al iniciar reproducción: **adquirir un &quot;lease&quot; exclusivo**. Si ya hay uno, **cancelar** la reproducción anterior o **bloquear** el intento actual con UI de aviso.&#10;- **Liberar** antes de cambiar de canal o engine. Introducir **cooldown 1–3 s** al cambiar para evitar que el servidor cuente conexiones solapadas.&#10;- En **casting**: transferir sesión y **detener inmediatamente** la reproducción local.&#10;- En **VLC fallback**: **release** de Media3 antes de crear LibVLC (y viceversa).&#10;- Los **requests de API/EPG** pueden ser concurrentes; la **restricción aplica solo al stream** (live/VOD).&#10;- No hacer &quot;preplay&quot; que abra sockets HLS/DASH de un segundo canal (permitido: precargar UI; **prohibido** precargar stream).&#10;&#10;### Componentes arquitectónicos obligatorios&#10;&#10;#### `StreamingLeaseManager` (singleton en `core.player`)&#10;- **Estado**: `None | Acquired(ownerId)` + `cooldownUntil`&#10;- **API**: `tryAcquire(ownerId)`, `forceAcquire(ownerId)`, `release(ownerId)`, `withLease(ownerId) { ... }`&#10;&#10;#### `PlayerCoordinator`&#10;- Orquesta `PlayerEngine` y habla con `StreamingLeaseManager`&#10;- Garantiza **1 engine vivo** y **0 overlaps** al hacer `play/switch/stop`&#10;&#10;#### `PlayerEngine` (interfaz)&#10;- Implementaciones: `Media3Engine` y `VlcEngine`&#10;&#10;---&#10;&#10;## Xtream Codes&#10;&#10;### Endpoints y autenticación&#10;- **Login y catálogos**: `player_api.php`&#10;- **Streams**: `.../live/&lt;u&gt;/&lt;p&gt;/&lt;streamId&gt;.m3u8` (preferido) o `.ts/.mp4`&#10;- **Headers**: Respetar headers por canal (`User-Agent`, `Referer`, `Authorization`)&#10;&#10;### Seguridad&#10;- **Nunca** loggear credenciales/URLs completas&#10;- Usar **EncryptedSharedPreferences** para almacenamiento de credenciales&#10;- Redactar URLs en logs: `url.replaceAfterLast(&quot;/&quot;, &quot;***&quot;)`&#10;&#10;---&#10;&#10;## UI/UX (Compose)&#10;&#10;### Gestión de lease ocupado&#10;- Al intentar reproducir con lease ocupado:&#10;  - Mostrar diálogo: &quot;Ya hay una reproducción activa. ¿Detener y reproducir este canal?&quot;&#10;  - Botones: **Cambiar** (libera anterior y toma lease) / **Cancelar**&#10;- Deshabilitar &quot;Play&quot; si `cooldown` activo; mostrar contador breve&#10;- En transfer a Cast: aviso &quot;Reproducción movida a dispositivo X&quot;&#10;&#10;---&#10;&#10;## Telemetría y monitoring&#10;&#10;### Eventos a registrar&#10;- `play_start`, `play_end`, `lease_acquire`, `lease_blocked`, `switch_engine`, `cast_transfer`&#10;- **Metadatos**: `engine`, `channelId/streamId`, `host`, `bitrate`, `bufferMs`, `errorCode`&#10;&#10;---&#10;&#10;## Testing estratégico&#10;&#10;### Unit tests&#10;- `StreamingLeaseManager`: carreras, release, cooldown&#10;- `PlayerCoordinator`: no overlaps&#10;- Parsers M3U/XMLTV&#10;- Repositorios Xtream&#10;&#10;### Instrumented tests&#10;- Room&#10;- Repositorios con network&#10;&#10;### UI tests&#10;- Flujos de &quot;lease ocupado&quot; y &quot;cooldown&quot;&#10;&#10;---&#10;&#10;## Antipatrones (nunca sugerir)&#10;- ❌ Dos players simultáneos (incluye PiP o prebuffer)&#10;- ❌ Cambiar de canal sin `release()` previo&#10;- ❌ Fallback a VLC **sin** cerrar Media3 primero&#10;- ❌ &quot;Preplay&quot; del siguiente canal que abra socket HLS/DASH&#10;- ❌ Logs con credenciales/URLs completas&#10;&#10;---&#10;&#10;## Plantillas de código&#10;&#10;### `StreamingLeaseManager`&#10;```kotlin&#10;@Singleton&#10;class StreamingLeaseManager @Inject constructor(&#10;    private val clock: Clock = Clock.systemUTC()&#10;) {&#10;    private val mutex = Mutex()&#10;    private var owner: String? = null&#10;    private var cooldownUntil: Instant? = null&#10;&#10;    private val _state = MutableStateFlow&lt;LeaseState&gt;(LeaseState.None)&#10;    val state: StateFlow&lt;LeaseState&gt; = _state.asStateFlow()&#10;&#10;    suspend fun tryAcquire(ownerId: String): Boolean = mutex.withLock {&#10;        val now = Instant.now(clock)&#10;        if (cooldownUntil?.isAfter(now) == true) return false&#10;        if (owner == null) {&#10;            owner = ownerId&#10;            _state.value = LeaseState.Acquired(ownerId)&#10;            true&#10;        } else {&#10;            false&#10;        }&#10;    }&#10;&#10;    suspend fun forceAcquire(ownerId: String) = mutex.withLock {&#10;        owner = ownerId&#10;        cooldownUntil = null&#10;        _state.value = LeaseState.Acquired(ownerId)&#10;    }&#10;&#10;    suspend fun release(ownerId: String, cooldown: Duration = Duration.ofSeconds(2)) = mutex.withLock {&#10;        if (owner == ownerId) {&#10;            owner = null&#10;            cooldownUntil = Instant.now(clock).plus(cooldown)&#10;            _state.value = LeaseState.None&#10;        }&#10;    }&#10;&#10;    sealed interface LeaseState {&#10;        data object None : LeaseState&#10;        data class Acquired(val ownerId: String) : LeaseState&#10;    }&#10;}&#10;```&#10;&#10;### `PlayerCoordinator`&#10;```kotlin&#10;@Singleton&#10;class PlayerCoordinator @Inject constructor(&#10;    private val selector: PlayerSelector,&#10;    private val lease: StreamingLeaseManager&#10;) {&#10;    private var engine: PlayerEngine? = null&#10;    private var ownerId: String? = null&#10;&#10;    suspend fun play(ownerId: String, media: MediaSpec): Boolean {&#10;        val acquired = lease.tryAcquire(ownerId)&#10;        if (!acquired) return false // UI mostrará diálogo para forzar&#10;&#10;        stopInternal() // seguridad extra (no overlap)&#10;        engine = selector.create()&#10;        this.ownerId = ownerId&#10;        engine!!.setMedia(media)&#10;        engine!!.play()&#10;        return true&#10;    }&#10;&#10;    suspend fun forcePlay(ownerId: String, media: MediaSpec) {&#10;        lease.forceAcquire(ownerId)&#10;        stopInternal()&#10;        engine = selector.create()&#10;        this.ownerId = ownerId&#10;        engine!!.setMedia(media)&#10;        engine!!.play()&#10;    }&#10;&#10;    suspend fun switchChannel(ownerId: String, media: MediaSpec) {&#10;        // Cambio &quot;hard&quot;: liberar antes de preparar el nuevo&#10;        engine?.pause()&#10;        engine?.release()&#10;        engine = selector.create()&#10;        this.ownerId = ownerId&#10;        engine!!.setMedia(media)&#10;        engine!!.play()&#10;    }&#10;&#10;    suspend fun stop(ownerId: String) {&#10;        if (this.ownerId == ownerId) {&#10;            stopInternal()&#10;            lease.release(ownerId)&#10;        }&#10;    }&#10;&#10;    suspend fun stopAll() {&#10;        stopInternal()&#10;        lease.forceAcquire(&quot;system_cleanup&quot;)&#10;        lease.release(&quot;system_cleanup&quot;)&#10;    }&#10;&#10;    private fun stopInternal() {&#10;        engine?.release()&#10;        engine = null&#10;        this.ownerId = null&#10;    }&#10;}&#10;```&#10;&#10;### ViewModel con diálogo de lease ocupado&#10;```kotlin&#10;fun onPlayRequested(stream: MediaSpec) = viewModelScope.launch {&#10;    val ownerId = &quot;player:${stream.url.hashCode()}&quot;&#10;    val started = coordinator.play(ownerId, stream)&#10;    if (!started) {&#10;        _ui.update { it.copy(showLeaseDialog = true, pendingStream = stream) }&#10;    }&#10;}&#10;&#10;fun onConfirmForcePlay() = viewModelScope.launch {&#10;    ui.value.pendingStream?.let { pending -&gt;&#10;        val ownerId = &quot;player:${pending.url.hashCode()}&quot;&#10;        coordinator.forcePlay(ownerId, pending)&#10;        _ui.update { it.copy(showLeaseDialog = false, pendingStream = null) }&#10;    }&#10;}&#10;```&#10;&#10;### Transferencia a Cast&#10;```kotlin&#10;castManager.onSessionStarted { device -&gt;&#10;    viewModelScope.launch {&#10;        coordinator.stop(currentOwnerId) // corta conexión local inmediatamente&#10;        // preparar MediaItem para Cast (solo Media3)&#10;        castController.play(remoteMediaItem)&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## Configuración de DataStore (Protobuf)&#10;&#10;### `app/src/main/proto/settings.proto`&#10;```proto&#10;syntax = &quot;proto3&quot;;&#10;option java_package = &quot;com.kyberstream.settings&quot;;&#10;option java_multiple_files = true;&#10;&#10;message Settings {&#10;  enum PlayerPref {&#10;    AUTO = 0;&#10;    MEDIA3 = 1;&#10;    VLC = 2;&#10;  }&#10;&#10;  // Player preferido (principal/alternativo/auto)&#10;  PlayerPref player_pref = 1;&#10;&#10;  // Si es true, corta la reproducción al ir a background&#10;  bool stop_on_background = 2;&#10;&#10;  // Cooldown en ms entre cierres/aberturas para evitar doble conexión&#10;  int32 cooldown_ms = 3;&#10;&#10;  // Habilita fallback automático a VLC cuando Media3 falla&#10;  bool enable_auto_fallback = 4;&#10;}&#10;```&#10;&#10;### Configuración Gradle&#10;```kotlin&#10;// En app/build.gradle.kts&#10;plugins {&#10;    id(&quot;com.google.protobuf&quot;) version &quot;0.9.4&quot;&#10;}&#10;&#10;dependencies {&#10;    implementation(&quot;androidx.datastore:datastore:1.1.1&quot;)&#10;    implementation(&quot;com.google.protobuf:protobuf-javalite:3.25.5&quot;)&#10;    implementation(&quot;androidx.security:security-crypto:1.1.0-alpha06&quot;)&#10;}&#10;&#10;protobuf {&#10;    protoc {&#10;        artifact = &quot;com.google.protobuf:protoc:3.25.5&quot;&#10;    }&#10;    generateProtoTasks {&#10;        all().forEach { task -&gt;&#10;            task.builtins {&#10;                register(&quot;java&quot;) {&#10;                    option(&quot;lite&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## Lifecycle Management&#10;&#10;### PlaybackLifecycleObserver&#10;```kotlin&#10;@Singleton&#10;class PlaybackLifecycleObserver @Inject constructor(&#10;    private val settings: SettingsDataStore,&#10;    private val coordinator: PlayerCoordinator&#10;) : DefaultLifecycleObserver {&#10;&#10;    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)&#10;    @Volatile private var stopOnBackground: Boolean = true&#10;&#10;    init {&#10;        scope.launch {&#10;            settings.settings.collect { stopOnBackground = it.stopOnBackground }&#10;        }&#10;    }&#10;&#10;    override fun onStop(owner: LifecycleOwner) {&#10;        // App se fue a background&#10;        if (stopOnBackground) {&#10;            scope.launch {&#10;                coordinator.stopAll()&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## Seguridad Xtream Codes&#10;&#10;### Almacenamiento seguro&#10;```kotlin&#10;@Singleton&#10;class XtreamSecureStore @Inject constructor(&#10;    @ApplicationContext private val context: Context&#10;) {&#10;    private val prefs by lazy {&#10;        val masterKey = MasterKey.Builder(context)&#10;            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)&#10;            .build()&#10;        EncryptedSharedPreferences.create(&#10;            context,&#10;            &quot;secrets_xtream&quot;,&#10;            masterKey,&#10;            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,&#10;            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM&#10;        )&#10;    }&#10;&#10;    fun save(secrets: XtreamSecrets) {&#10;        prefs.edit()&#10;            .putString(&quot;baseUrl&quot;, secrets.baseUrl.trimEnd('/') + &quot;/&quot;)&#10;            .putString(&quot;username&quot;, secrets.username)&#10;            .putString(&quot;password&quot;, secrets.password)&#10;            .apply()&#10;    }&#10;&#10;    fun load(): XtreamSecrets? {&#10;        val base = prefs.getString(&quot;baseUrl&quot;, null) ?: return null&#10;        val user = prefs.getString(&quot;username&quot;, null) ?: return null&#10;        val pass = prefs.getString(&quot;password&quot;, null) ?: return null&#10;        return XtreamSecrets(base, user, pass)&#10;    }&#10;&#10;    fun clear() = prefs.edit().clear().apply()&#10;}&#10;```&#10;&#10;---&#10;&#10;## Checklist de Pull Request&#10;&#10;* [ ] `StreamingLeaseManager` y `PlayerCoordinator` implementados y testeados&#10;* [ ] **Cero overlaps** en logs: cada play libera el anterior antes de abrir conexión&#10;* [ ] Cooldown aplicado (≥ 1 s) al cambiar/stop&#10;* [ ] Transferencia a Cast corta local de inmediato&#10;* [ ] Fallback a VLC **después** de liberar Media3&#10;* [ ] Sin prebuffer de streams; solo UI&#10;* [ ] Credenciales Xtream seguras y sin filtraciones en logs&#10;* [ ] Lifecycle observer registrado correctamente&#10;* [ ] DataStore configurado con protobuf&#10;* [ ] Tests unitarios para componentes críticos&#10;&#10;---&#10;&#10;**Objetivo**: Cumplir la política **single-connection** del proveedor IPTV, evitando desconexiones y baneos, con UX clara y código estable, moderno y testeable.&#10;" />
              <option name="updatedContent" value="# GitHub Copilot Instructions — IPTV Android (Media3 + VLC + Xtream Codes, single-connection)&#10;&#10;&gt; **Contexto**&#10;&gt; App IPTV para Android (TV y móvil) con Xtream Codes (live/VOD/series/EPG). **Solo se permite 1 conexión de streaming activa por dispositivo**. Player principal: **Media3**. Alternativo: **VLC (LibVLC)**. DI con Hilt, UI en Compose.&#10;&#10;---&#10;&#10;## Idioma de comunicación&#10;- **Toda la comunicación, respuestas y generación de código por parte del asistente deben ser en español latino.**&#10;&#10;---&#10;&#10;## Estilo y lenguaje de código&#10;- Comentarios en **español latino**.&#10;- Identificadores en **inglés** (`camelCase` / `PascalCase`).&#10;- Formato con **ktlint/spotless**.&#10;&#10;## Stack tecnológico (fijo)&#10;- **Kotlin**: 2.2.0&#10;- **AGP**: 8.12.0  &#10;- **KSP**: 2.2.0-2.0.2&#10;- **UI**: Compose + Hilt&#10;- **Async**: Coroutines/Flow&#10;- **Player**: Media3 (ExoPlayer) + LibVLC (alternativo)&#10;- **Network**: Retrofit o Ktor + kotlinx.serialization&#10;- **Storage**: Room + DataStore (proto) + EncryptedSharedPreferences&#10;- **Background**: WorkManager&#10;- **Image**: Coil&#10;- **Logging**: Timber&#10;&#10;---&#10;&#10;## Regla fundamental: **Single Streaming Connection**&#10;&#10;### Restricciones obligatorias&#10;- **Nunca** tener dos reproducciones simultáneas (local, PiP, background, o cast).&#10;- Al iniciar reproducción: **adquirir un &quot;lease&quot; exclusivo**. Si ya hay uno, **cancelar** la reproducción anterior o **bloquear** el intento actual con UI de aviso.&#10;- **Liberar** antes de cambiar de canal o engine. Introducir **cooldown 1–3 s** al cambiar para evitar que el servidor cuente conexiones solapadas.&#10;- En **casting**: transferir sesión y **detener inmediatamente** la reproducción local.&#10;- En **VLC fallback**: **release** de Media3 antes de crear LibVLC (y viceversa).&#10;- Los **requests de API/EPG** pueden ser concurrentes; la **restricción aplica solo al stream** (live/VOD).&#10;- No hacer &quot;preplay&quot; que abra sockets HLS/DASH de un segundo canal (permitido: precargar UI; **prohibido** precargar stream).&#10;&#10;### Componentes arquitectónicos obligatorios&#10;&#10;#### `StreamingLeaseManager` (singleton en `core.player`)&#10;- **Estado**: `None | Acquired(ownerId)` + `cooldownUntil`&#10;- **API**: `tryAcquire(ownerId)`, `forceAcquire(ownerId)`, `release(ownerId)`, `withLease(ownerId) { ... }`&#10;&#10;#### `PlayerCoordinator`&#10;- Orquesta `PlayerEngine` y habla con `StreamingLeaseManager`&#10;- Garantiza **1 engine vivo** y **0 overlaps** al hacer `play/switch/stop`&#10;&#10;#### `PlayerEngine` (interfaz)&#10;- Implementaciones: `Media3Engine` y `VlcEngine`&#10;&#10;---&#10;&#10;## Xtream Codes&#10;&#10;### Endpoints y autenticación&#10;- **Login y catálogos**: `player_api.php`&#10;- **Streams**: `.../live/&lt;u&gt;/&lt;p&gt;/&lt;streamId&gt;.m3u8` (preferido) o `.ts/.mp4`&#10;- **Headers**: Respetar headers por canal (`User-Agent`, `Referer`, `Authorization`)&#10;&#10;### Seguridad&#10;- **Nunca** loggear credenciales/URLs completas&#10;- Usar **EncryptedSharedPreferences** para almacenamiento de credenciales&#10;- Redactar URLs en logs: `url.replaceAfterLast(&quot;/&quot;, &quot;***&quot;)`&#10;&#10;---&#10;&#10;## Datos de acceso para pruebas internas Xtream Codes&#10;&#10;&gt; **Importante:** Los siguientes datos de acceso son exclusivamente para pruebas internas de conexión al servicio Xtream Codes. No deben usarse en producción ni compartirse fuera del equipo de desarrollo.&#10;&#10;- **Usuario:** DMWyCAxket&#10;- **Contraseña:** kfvRWYajJJ&#10;- **URL:** http://gzytv.vip:8880&#10;&#10;---&#10;&#10;## UI/UX (Compose)&#10;&#10;### Gestión de lease ocupado&#10;- Al intentar reproducir con lease ocupado:&#10;  - Mostrar diálogo: &quot;Ya hay una reproducción activa. ¿Detener y reproducir este canal?&quot;&#10;  - Botones: **Cambiar** (libera anterior y toma lease) / **Cancelar**&#10;- Deshabilitar &quot;Play&quot; si `cooldown` activo; mostrar contador breve&#10;- En transfer a Cast: aviso &quot;Reproducción movida a dispositivo X&quot;&#10;&#10;---&#10;&#10;## Telemetría y monitoring&#10;&#10;### Eventos a registrar&#10;- `play_start`, `play_end`, `lease_acquire`, `lease_blocked`, `switch_engine`, `cast_transfer`&#10;- **Metadatos**: `engine`, `channelId/streamId`, `host`, `bitrate`, `bufferMs`, `errorCode`&#10;&#10;---&#10;&#10;## Testing estratégico&#10;&#10;### Unit tests&#10;- `StreamingLeaseManager`: carreras, release, cooldown&#10;- `PlayerCoordinator`: no overlaps&#10;- Parsers M3U/XMLTV&#10;- Repositorios Xtream&#10;&#10;### Instrumented tests&#10;- Room&#10;- Repositorios con network&#10;&#10;### UI tests&#10;- Flujos de &quot;lease ocupado&quot; y &quot;cooldown&quot;&#10;&#10;---&#10;&#10;## Antipatrones (nunca sugerir)&#10;- ❌ Dos players simultáneos (incluye PiP o prebuffer)&#10;- ❌ Cambiar de canal sin `release()` previo&#10;- ❌ Fallback a VLC **sin** cerrar Media3 primero&#10;- ❌ &quot;Preplay&quot; del siguiente canal que abra socket HLS/DASH&#10;- ❌ Logs con credenciales/URLs completas&#10;&#10;---&#10;&#10;## Plantillas de código&#10;&#10;### `StreamingLeaseManager`&#10;```kotlin&#10;@Singleton&#10;class StreamingLeaseManager @Inject constructor(&#10;    private val clock: Clock = Clock.systemUTC()&#10;) {&#10;    private val mutex = Mutex()&#10;    private var owner: String? = null&#10;    private var cooldownUntil: Instant? = null&#10;&#10;    private val _state = MutableStateFlow&lt;LeaseState&gt;(LeaseState.None)&#10;    val state: StateFlow&lt;LeaseState&gt; = _state.asStateFlow()&#10;&#10;    suspend fun tryAcquire(ownerId: String): Boolean = mutex.withLock {&#10;        val now = Instant.now(clock)&#10;        if (cooldownUntil?.isAfter(now) == true) return false&#10;        if (owner == null) {&#10;            owner = ownerId&#10;            _state.value = LeaseState.Acquired(ownerId)&#10;            true&#10;        } else {&#10;            false&#10;        }&#10;    }&#10;&#10;    suspend fun forceAcquire(ownerId: String) = mutex.withLock {&#10;        owner = ownerId&#10;        cooldownUntil = null&#10;        _state.value = LeaseState.Acquired(ownerId)&#10;    }&#10;&#10;    suspend fun release(ownerId: String, cooldown: Duration = Duration.ofSeconds(2)) = mutex.withLock {&#10;        if (owner == ownerId) {&#10;            owner = null&#10;            cooldownUntil = Instant.now(clock).plus(cooldown)&#10;            _state.value = LeaseState.None&#10;        }&#10;    }&#10;&#10;    sealed interface LeaseState {&#10;        data object None : LeaseState&#10;        data class Acquired(val ownerId: String) : LeaseState&#10;    }&#10;}&#10;```&#10;&#10;### `PlayerCoordinator`&#10;```kotlin&#10;@Singleton&#10;class PlayerCoordinator @Inject constructor(&#10;    private val selector: PlayerSelector,&#10;    private val lease: StreamingLeaseManager&#10;) {&#10;    private var engine: PlayerEngine? = null&#10;    private var ownerId: String? = null&#10;&#10;    suspend fun play(ownerId: String, media: MediaSpec): Boolean {&#10;        val acquired = lease.tryAcquire(ownerId)&#10;        if (!acquired) return false // UI mostrará diálogo para forzar&#10;&#10;        stopInternal() // seguridad extra (no overlap)&#10;        engine = selector.create()&#10;        this.ownerId = ownerId&#10;        engine!!.setMedia(media)&#10;        engine!!.play()&#10;        return true&#10;    }&#10;&#10;    suspend fun forcePlay(ownerId: String, media: MediaSpec) {&#10;        lease.forceAcquire(ownerId)&#10;        stopInternal()&#10;        engine = selector.create()&#10;        this.ownerId = ownerId&#10;        engine!!.setMedia(media)&#10;        engine!!.play()&#10;    }&#10;&#10;    suspend fun switchChannel(ownerId: String, media: MediaSpec) {&#10;        // Cambio &quot;hard&quot;: liberar antes de preparar el nuevo&#10;        engine?.pause()&#10;        engine?.release()&#10;        engine = selector.create()&#10;        this.ownerId = ownerId&#10;        engine!!.setMedia(media)&#10;        engine!!.play()&#10;    }&#10;&#10;    suspend fun stop(ownerId: String) {&#10;        if (this.ownerId == ownerId) {&#10;            stopInternal()&#10;            lease.release(ownerId)&#10;        }&#10;    }&#10;&#10;    suspend fun stopAll() {&#10;        stopInternal()&#10;        lease.forceAcquire(&quot;system_cleanup&quot;)&#10;        lease.release(&quot;system_cleanup&quot;)&#10;    }&#10;&#10;    private fun stopInternal() {&#10;        engine?.release()&#10;        engine = null&#10;        this.ownerId = null&#10;    }&#10;}&#10;```&#10;&#10;### ViewModel con diálogo de lease ocupado&#10;```kotlin&#10;fun onPlayRequested(stream: MediaSpec) = viewModelScope.launch {&#10;    val ownerId = &quot;player:${stream.url.hashCode()}&quot;&#10;    val started = coordinator.play(ownerId, stream)&#10;    if (!started) {&#10;        _ui.update { it.copy(showLeaseDialog = true, pendingStream = stream) }&#10;    }&#10;}&#10;&#10;fun onConfirmForcePlay() = viewModelScope.launch {&#10;    ui.value.pendingStream?.let { pending -&gt;&#10;        val ownerId = &quot;player:${pending.url.hashCode()}&quot;&#10;        coordinator.forcePlay(ownerId, pending)&#10;        _ui.update { it.copy(showLeaseDialog = false, pendingStream = null) }&#10;    }&#10;}&#10;```&#10;&#10;### Transferencia a Cast&#10;```kotlin&#10;castManager.onSessionStarted { device -&gt;&#10;    viewModelScope.launch {&#10;        coordinator.stop(currentOwnerId) // corta conexión local inmediatamente&#10;        // preparar MediaItem para Cast (solo Media3)&#10;        castController.play(remoteMediaItem)&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## Configuración de DataStore (Protobuf)&#10;&#10;### `app/src/main/proto/settings.proto`&#10;```proto&#10;syntax = &quot;proto3&quot;;&#10;option java_package = &quot;com.kyberstream.settings&quot;;&#10;option java_multiple_files = true;&#10;&#10;message Settings {&#10;  enum PlayerPref {&#10;    AUTO = 0;&#10;    MEDIA3 = 1;&#10;    VLC = 2;&#10;  }&#10;&#10;  // Player preferido (principal/alternativo/auto)&#10;  PlayerPref player_pref = 1;&#10;&#10;  // Si es true, corta la reproducción al ir a background&#10;  bool stop_on_background = 2;&#10;&#10;  // Cooldown en ms entre cierres/aberturas para evitar doble conexión&#10;  int32 cooldown_ms = 3;&#10;&#10;  // Habilita fallback automático a VLC cuando Media3 falla&#10;  bool enable_auto_fallback = 4;&#10;}&#10;```&#10;&#10;### Configuración Gradle&#10;```kotlin&#10;// En app/build.gradle.kts&#10;plugins {&#10;    id(&quot;com.google.protobuf&quot;) version &quot;0.9.4&quot;&#10;}&#10;&#10;dependencies {&#10;    implementation(&quot;androidx.datastore:datastore:1.1.1&quot;)&#10;    implementation(&quot;com.google.protobuf:protobuf-javalite:3.25.5&quot;)&#10;    implementation(&quot;androidx.security:security-crypto:1.1.0-alpha06&quot;)&#10;}&#10;&#10;protobuf {&#10;    protoc {&#10;        artifact = &quot;com.google.protobuf:protoc:3.25.5&quot;&#10;    }&#10;    generateProtoTasks {&#10;        all().forEach { task -&gt;&#10;            task.builtins {&#10;                register(&quot;java&quot;) {&#10;                    option(&quot;lite&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## Lifecycle Management&#10;&#10;### PlaybackLifecycleObserver&#10;```kotlin&#10;@Singleton&#10;class PlaybackLifecycleObserver @Inject constructor(&#10;    private val settings: SettingsDataStore,&#10;    private val coordinator: PlayerCoordinator&#10;) : DefaultLifecycleObserver {&#10;&#10;    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)&#10;    @Volatile private var stopOnBackground: Boolean = true&#10;&#10;    init {&#10;        scope.launch {&#10;            settings.settings.collect { stopOnBackground = it.stopOnBackground }&#10;        }&#10;    }&#10;&#10;    override fun onStop(owner: LifecycleOwner) {&#10;        // App se fue a background&#10;        if (stopOnBackground) {&#10;            scope.launch {&#10;                coordinator.stopAll()&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;---&#10;&#10;## Seguridad Xtream Codes&#10;&#10;### Almacenamiento seguro&#10;```kotlin&#10;@Singleton&#10;class XtreamSecureStore @Inject constructor(&#10;    @ApplicationContext private val context: Context&#10;) {&#10;    private val prefs by lazy {&#10;        val masterKey = MasterKey.Builder(context)&#10;            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)&#10;            .build()&#10;        EncryptedSharedPreferences.create(&#10;            context,&#10;            &quot;secrets_xtream&quot;,&#10;            masterKey,&#10;            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,&#10;            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM&#10;        )&#10;    }&#10;&#10;    fun save(secrets: XtreamSecrets) {&#10;        prefs.edit()&#10;            .putString(&quot;baseUrl&quot;, secrets.baseUrl.trimEnd('/') + &quot;/&quot;)&#10;            .putString(&quot;username&quot;, secrets.username)&#10;            .putString(&quot;password&quot;, secrets.password)&#10;            .apply()&#10;    }&#10;&#10;    fun load(): XtreamSecrets? {&#10;        val base = prefs.getString(&quot;baseUrl&quot;, null) ?: return null&#10;        val user = prefs.getString(&quot;username&quot;, null) ?: return null&#10;        val pass = prefs.getString(&quot;password&quot;, null) ?: return null&#10;        return XtreamSecrets(base, user, pass)&#10;    }&#10;&#10;    fun clear() = prefs.edit().clear().apply()&#10;}&#10;```&#10;&#10;---&#10;&#10;## Checklist de Pull Request&#10;&#10;* [ ] `StreamingLeaseManager` y `PlayerCoordinator` implementados y testeados&#10;* [ ] **Cero overlaps** en logs: cada play libera el anterior antes de abrir conexión&#10;* [ ] Cooldown aplicado (≥ 1 s) al cambiar/stop&#10;* [ ] Transferencia a Cast corta local de inmediato&#10;* [ ] Fallback a VLC **después** de liberar Media3&#10;* [ ] Sin prebuffer de streams; solo UI&#10;* [ ] Credenciales Xtream seguras y sin filtraciones en logs&#10;* [ ] Lifecycle observer registrado correctamente&#10;* [ ] DataStore configurado con protobuf&#10;* [ ] Tests unitarios para componentes críticos&#10;&#10;---&#10;&#10;**Objetivo**: Cumplir la política **single-connection** del proveedor IPTV, evitando desconexiones y baneos, con UX clara y código estable, moderno y testeable." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>